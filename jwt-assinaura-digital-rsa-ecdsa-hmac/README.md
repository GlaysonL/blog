## Quando decidimos utilizar JWT em nossas API's e frontend SPA, precisamos utilizar um algoritmo para emitir um token. Há diversas opções para assinar o JWT. Ele deve ser simétrico ou assimétrico. Probabilistico ou deterministico. Veja neste artigo como assinar digitalmente seu JWT utilizando ASP.NET Core

Ao gerar um JWT é necessário informar um algoritmo de criptografia. Como por exemplo:

```csharp
// gerador de jws / jwe
var tokenHandler = new JsonWebTokenHandler();

// Criando chave assimetrica
var key = new RsaSecurityKey(RSA.Create(2048));

// criando o jwt
var jwt = new SecurityTokenDescriptor
{
    Issuer = "www.mysite.com",
    Audience = "your-spa",
    // Details hide
    SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSsaPssSha256) // <-- Algoritmo probabilistico
};
// assinando o jwt
string jws = tokenHandler.CreateToken(jwt);
Console.WriteLine(jws);
```

Além do RSA é possivel utilizar chaves simétricas e ECDSA.

Para saber escolher o algoritmo, é necessário entender onde cada um deles se encaixa.

## Algoritmos

Um algoritmo de criptografia pode ser considerado como uma fórmula, pois é um conjunto de procedimentos matemáticos. Através do uso desse algoritmo as informações são transformadas em Ciphertext (texto cifrado) e requerem o uso de uma chave para transformar os dados em sua forma original.

![crypto](https://www.brunobrito.net.br/content/images/2020/02/crypto.gif)

## JWT com chave simétrica

Para utilizar um algoritmo simétrico é necessário apenas uma única chave, pois ela será utilizada para criptografar os dados e na descriptografia dos mesmos. Nesse caso as duas partes envolvidas numa comunicação precisam ter a chave, seja para leitura ou para escrever uma nova.

![symmetric-encryption-1](https://www.brunobrito.net.br/content/images/2020/02/symmetric-encryption-1.png)

### HMAC

Hash-Based Message Authentication Codes (HMACs) são um grupo de algoritmos que utilizam uma chave simétrica para assinar as mensagens e sua segurança está ligada a função hash utilizada, por exemplo, SHA256.

### Quando utilizar uma chave simétrica?

Apenas em cenários onde haverá UMA única API, pois as demais API's não irão ter habilidade para validar o JWS, ao menos que a chave privada seja compartilhada entre as API's. 

Se você trabalha num time pequeno esse risco pode ser tolerável. Em times médios e grandes é uma potencial brecha de segurança. 

Afinal... Qualquer time em posse da chave privada poderá gerar Tokens e fazer impersonate das permissões e usuários, assim conseguindo acessos privilegiados em suas API's.

No final do dia o desafio é garantir que a sua chave será devidamente armazenada e somente compartilhada por entidades confiáveis.

### Gerando uma chave simétrica HMAC

Ao gerar uma chave simétrica você deve se questionar: Somente uma API vai gerar o JWT ou mais serviços terão esse direito? (Não há problema se no futuro essa estratégia mudar).

Por que essa pergunta é importante? Ao gerar uma chave o tamanho dos bytes importam, há recomendações sobre o tamanho da chave.

O NIST publicou um documento [Recommendation for Applications Using Approved Hash Algorithms, Security Effect of the HMAC Key Section - 5.3.4](https://csrc.nist.gov/publications/detail/sp/800-107/rev-1/final) onde faz importantes recomendações em relação a chave e o algoritmo que será utilizado.

![image](https://user-images.githubusercontent.com/7241156/167740499-fd529bba-325d-4622-82a9-bb87b5686da6.png)

Assim como o NIST a própria Microsoft reforça o tamanho da chave (links no final).

Sabendo disto, é possível gerar uma chave automaticamente com os componentes do .NET, dessa forma a API poderá armezenar a chave em algum lugar e recuperar toda vez que for assinar um JWT. Isso garante segurança, pois uma vez que o registro for removido uma nova chave totalmente aleatória será gerada.

Fazendo desta forma haverá uma pequena burocracia extra, pois compartilhar a chave significa compartilhar o JWK. Seja através de um arquivo físico ou pelo banco de dados.

```csharp
static void Main(string[] args)
{
    var tokenHandler = new JsonWebTokenHandler();
    SecurityKey key = null;

    // HMAC Key
    key = AutoGeneratedHmac(64);

    // Hmac Sha256
    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
    Console.WriteLine($"{tokenHandler.CreateToken(Jwt)}{Environment.NewLine}");

    // HMAC Sha 384
    key = AutoGeneratedHmac(128);
    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha384);
    Console.WriteLine($"{tokenHandler.CreateToken(Jwt)}{Environment.NewLine}");

    // Hmac Sha 512
    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha512);
    Console.WriteLine($"{tokenHandler.CreateToken(Jwt)}{Environment.NewLine}");
}

private static RandomNumberGenerator Rng = RandomNumberGenerator.Create();
private static DateTime Now = DateTime.Now;

private static SecurityTokenDescriptor Jwt = new SecurityTokenDescriptor
{
    Issuer = "www.mysite.com",
    Audience = "your-spa",
    IssuedAt = Now,
    NotBefore = Now,
    Expires = Now.AddHours(1),
    Subject = new ClaimsIdentity(new List<Claim>
    {
        new Claim(JwtRegisteredClaimNames.Email, "meuemail@gmail.com", ClaimValueTypes.Email),
        new Claim(JwtRegisteredClaimNames.GivenName, "Bruno Brito"),
        new Claim(JwtRegisteredClaimNames.Sub, Guid.NewGuid().ToString())
    })
};


private static SecurityKey AutoGeneratedHmac(int bytes)
{
    return new SymmetricSecurityKey(GenerateHmacKey(bytes));
}


private static byte[] GenerateHmacKey(int bytes)
{
    byte[] data = new byte[bytes];
    Rng.GetBytes(data);
    return data;
}
```

Neste exemplo o que merece destaque é a utilização do objeto `[System.Security.Cryptography.RandomNumberGenerator]` para a geração da chave.

Entretanto essa implementação acima possui um problema. Caso a aplicação reinicie as chaves serão renovadas, assim invalidando os tokens gerados anteriormente.

Para resolver esse problema o objeto `[JsonWebKey]` tem como objetivo salvar os parâmetros da criptografia. Assim caso a aplicação seja reiniciada basta verificar se o objeto existe e o recuperar. Caso contrário será criado um novo.

```csharp
static void Main(string[] args)
{
    var tokenHandler = new JsonWebTokenHandler();
    var now = DateTime.Now;
    var key = AutoGeneratedHmac(64);

    var jwt = new SecurityTokenDescriptor
    {
        Issuer = "www.mysite.com",
        Audience = "your-spa",
        IssuedAt = now,
        NotBefore = now,
        Expires = now.AddHours(1),
        Subject = new ClaimsIdentity(new List<Claim>
        {
            new Claim(JwtRegisteredClaimNames.Email, "meuemail@gmail.com", ClaimValueTypes.Email),
            new Claim(JwtRegisteredClaimNames.GivenName, "Bruno Brito"),
            new Claim(JwtRegisteredClaimNames.Sub, Guid.NewGuid().ToString())
        }),
        SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256)
    };

    Console.WriteLine($"{tokenHandler.CreateToken(jwt)}{Environment.NewLine}");
    var jws = tokenHandler.CreateToken(jwt);

    // Store HMAC os Filesystem, recover and test if it's valid
    var jwk = JsonWebKeyConverter.ConvertFromSymmetricSecurityKey(key);
    jwk.KeyId = Guid.NewGuid().ToString();
    File.WriteAllText("current.key", JsonConvert.SerializeObject(jwk));


    // Now recover and verify if still valid
    var storedJwk = JsonConvert.DeserializeObject<JsonWebKey>(File.ReadAllText("current.key"));
    var validationResult = tokenHandler.ValidateToken(jws, new TokenValidationParameters
    {
        ValidIssuer = "www.mysite.com",
        ValidAudience = "your-spa",
        IssuerSigningKey = storedJwk

    });

    Console.WriteLine(validationResult.IsValid);
}

private static SymmetricSecurityKey AutoGeneratedHmac(int bytes)
{
    return new SymmetricSecurityKey(GenerateHmacKey(bytes));
}


private static RandomNumberGenerator Rng = RandomNumberGenerator.Create();


private static byte[] GenerateHmacKey(int bytes)
{
    byte[] data = new byte[bytes];
    Rng.GetBytes(data);
    return data;
}
```

## JWT com chave assimétrica

Um algoritmo assimétrico envolve duas chaves, uma chave pública e outra chave privada. Enquanto uma chave (privada) é usada para assinar digitalmente a mensagem a outra chave (pública) só pode ser usada para verificar a autenticidade da assinatura. 

![asymmetric-encryption-1](https://www.brunobrito.net.br/content/images/2020/02/asymmetric-encryption-1.png)

A [RFC 7518](https://tools.ietf.org/html/rfc7518) define os algoritmos RSA e ECDsa para assinar um JWT. Há diversas variações do RSA e ECDsa. Os exemplos irão utilizar os mais recomendados pela RFC 7518.

### RSA

RSA é o acrônimo de Rivest–Shamir–Adleman. É uma criptografia criada em 1977. E revolucionou os métodos utilizados na época, pois introduziu o conceito de chaves assimétricas. Até então os modelos de criptografia utilizavam a mesma chave para criptografar e descriptografar mensagens.

O RSA é muito utilizado para criar assinaturas digitais. O proprietário da chave privada é o único capaz de assinar uma mensagem. Enquanto a chave pública permite que qualquer entidade verifique a validade da assinatura.

### Elliptic Curves - ECDsa

Há diversas explicações técnicas sobre ECC (*Elliptic Curve Cryptography*). [Links abaixo para curiosos]. De maneira pratica o EC é melhor e mais eficiente que o RSA. Especialistas e entendidos sobre o assunto dizem que o ECC revolucionou os algoritmos assimétricos.

### Quando utilizar chave assimétrica?

A melhor resposta seria: Sempre que possível! 
Em ambientes que possuem uma única API, que não há uma URI para consultar a chave pública e não é um servidor OAuth 2.0. Não será um grande diferencial.

Agora considere que se você adotou a estratégia do exemplo anterior, começou a salvar a chave (JWK) em algum local como filesystem, banco de dados ou blob, então passar a utilizar chaves assimétricas vai fornecer um nível a mais de segurança.

OBS - Se estiver em um ambiente OAuth 2.0, a utilização de chaves assimétricas é obrigatório! Devido a natureza da especificação do OAuth 2.0.

### Gerando RSASSA-PSS using SHA-256 and MGF1 with SHA-256

Considere o seguinte código:

```csharp
public static void Run()
{
    var tokenHandler = new JsonWebTokenHandler();
    var key = new RsaSecurityKey(RSA.Create(2048))
    {
        KeyId = Guid.NewGuid().ToString()
    };

    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSsaPssSha256);
    Console.WriteLine($"{tokenHandler.CreateToken(Jwt)}{Environment.NewLine}");
}

private static DateTime Now = DateTime.Now;
private static SecurityTokenDescriptor Jwt = new SecurityTokenDescriptor
{
    Issuer = "www.mysite.com",
    Audience = "your-spa",
    IssuedAt = Now,
    NotBefore = Now,
    Expires = Now.AddHours(1),
    Subject = new ClaimsIdentity(new List<Claim>
    {
        new Claim(JwtRegisteredClaimNames.Email, "meuemail@gmail.com", ClaimValueTypes.Email),
        new Claim(JwtRegisteredClaimNames.GivenName, "Bruno Brito"),
        new Claim(JwtRegisteredClaimNames.Sub, Guid.NewGuid().ToString())
    })
};
private static TokenValidationParameters TokenValidationParams = new TokenValidationParameters
{
    ValidIssuer = "www.mysite.com",
    ValidAudience = "your-spa",
};
```

* O tamanho `[2048]` é o mínimo especificado pela RFC 7518 - section 3.5.

A utilização do RSA através do .NET é muito simples. Utilizando a mesma técnica do exemplo anterior é possível salvar os dados da chave criada e assim recarregar a mesma chave quando a aplicação reiniciar.

```csharp
public static void Run()
{
    var tokenHandler = new JsonWebTokenHandler();
    var key = new RsaSecurityKey(RSA.Create(2048))
    {
        KeyId = Guid.NewGuid().ToString()
    };

    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSsaPssSha256);
    var lastJws = tokenHandler.CreateToken(Jwt);

    Console.WriteLine($"{lastJws}{Environment.NewLine}");

    // Store in filesystem
    // Store HMAC os Filesystem, recover and test if it's valid
    var jwk = JsonWebKeyConverter.ConvertFromRSASecurityKey(key);
    File.WriteAllText("current-rsa.key", JsonConvert.SerializeObject(jwk));


    var storedJwk = JsonConvert.DeserializeObject<JsonWebKey>(File.ReadAllText("current-rsa.key"));
    TokenValidationParams.IssuerSigningKey = storedJwk;
    var validationResult = tokenHandler.ValidateToken(lastJws, TokenValidationParams);

    Console.WriteLine(validationResult.IsValid);
}
``` 

Bem simples né?

### Gerando ECDSA using P-256 and SHA-256 

Esse é o algoritmo mais recomendado pela RFC para utilizar na assinatura do seu JWT.

Igualmente ao RSA, sua utilização é muito simples:

```csharp
private static DateTime Now = DateTime.Now;
private static SecurityTokenDescriptor Jwt = new SecurityTokenDescriptor
{
    Issuer = "www.mysite.com",
    Audience = "your-spa",
    IssuedAt = Now,
    NotBefore = Now,
    Expires = Now.AddHours(1),
    Subject = new ClaimsIdentity(new List<Claim>
    {
        new Claim(JwtRegisteredClaimNames.Email, "meuemail@gmail.com", ClaimValueTypes.Email),
        new Claim(JwtRegisteredClaimNames.GivenName, "Bruno Brito"),
        new Claim(JwtRegisteredClaimNames.Sub, Guid.NewGuid().ToString())
    })
};
private static TokenValidationParameters TokenValidationParams = new TokenValidationParameters
{
    ValidIssuer = "www.mysite.com",
    ValidAudience = "your-spa",
};


public static void Run()
{
    var tokenHandler = new JsonWebTokenHandler();
    var key = new ECDsaSecurityKey(ECDsa.Create(ECCurve.NamedCurves.nistP256))
    {
        KeyId = Guid.NewGuid().ToString()
    };

    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.EcdsaSha256);
    var lastJws = tokenHandler.CreateToken(Jwt);

    Console.WriteLine($"{lastJws}{Environment.NewLine}");
}
```

A curva Nist P256 é especificado na própria RFC, por isso está sendo utilizada.

Para salvar em disco ou em outro local é muito simples fazer um parse:

```csharp
public static void Run()
{
    var tokenHandler = new JsonWebTokenHandler();
    var key = new ECDsaSecurityKey(ECDsa.Create(ECCurve.NamedCurves.nistP256))
    {
        KeyId = Guid.NewGuid().ToString()
    };

    Jwt.SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.EcdsaSha256);
    var lastJws = tokenHandler.CreateToken(Jwt);
    Console.WriteLine($"{lastJws}{Environment.NewLine}");


    // Store in filesystem
    // Store HMAC os Filesystem, recover and test if it's valid
    var parameters = key.ECDsa.ExportParameters(true);
    var jwk = new JsonWebKey()
    {
        Kty = JsonWebAlgorithmsKeyTypes.EllipticCurve,
        Use = "sig",
        Kid = key.KeyId,
        KeyId = key.KeyId,
        X = Base64UrlEncoder.Encode(parameters.Q.X),
        Y = Base64UrlEncoder.Encode(parameters.Q.Y),
        D = Base64UrlEncoder.Encode(parameters.D),
        Crv = JsonWebKeyECTypes.P256,
        Alg = "ES256"
    };

    File.WriteAllText("current-ecdsa.key", JsonConvert.SerializeObject(jwk));

    var storedJwk = JsonConvert.DeserializeObject<JsonWebKey>(File.ReadAllText("current-ecdsa.key"));
    TokenValidationParams.IssuerSigningKey = storedJwk;
    var validationResult = tokenHandler.ValidateToken(lastJws, TokenValidationParams);

    Console.WriteLine(validationResult.IsValid);
}
```


## Componente Jwks.Manager

Ao invés de fazer cada um desses algoritmos no braço e escolher aonde salvar, recomendo a utilização do componente [NetDevPack Security.Jwt](https://github.com/NetDevPack/Security.Jwt) que irá não só gerar o JWK, como fazer a gestão dele e eventualmente expirar após um tempo pré determinado.

## Download

O código do projeto está disponível no meu [GitHub](https://github.com/brunohbrito/Tests-RSA-ECDsa-HMAC-JWK)

## Conclusão

Muitas coisas sobre JWT e OAuth 2.0 são complexos na teoria. Porém essa complexidade é abstraida através dos diversos componentes disponiveis.

Espero que esse artigo te ajude a entender e também melhorar a segurança das suas API's.

## Referências

* [HMAC256 Constructor - Key Size recommendation](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha256.-ctor)
* [HMAC384 Constructor - Key Size recommendation](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha384.-ctor)
* [HMAC512 Constructor - Key Size recommendation](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha512.-ctor)
* [RFC 7518](https://tools.ietf.org/html/rfc7518)
* [A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/)
* [Serious Cryptography: A Practical Introduction to Modern Encryption](https://www.amazon.com/Serious-Cryptography-Practical-Introduction-Encryption/dp/1593278268)
